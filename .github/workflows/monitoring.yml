name: Monitoring and Performance Tests

on:
  schedule:
    # Run every hour
    - cron: '0 * * * *'
  workflow_dispatch:
  push:
    branches:
      - main
    paths:
      - 'monitoring/**'

jobs:
  performance-test:
    name: Performance Testing
    runs-on: ubuntu-latest
    if: github.event_name == 'schedule' || github.event_name == 'workflow_dispatch'
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Set up Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '20'
    
    - name: Install k6
      run: |
        sudo apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv-keys C5AD17C747E3415A3642D57D77C6C491D6AC1D69
        echo "deb https://dl.k6.io/deb stable main" | sudo tee /etc/apt/sources.list.d/k6.list
        sudo apt-get update
        sudo apt-get install k6
    
    - name: Run performance tests
      run: |
        k6 run --out json=performance-results.json testing/performance/load-test.js
      env:
        TARGET_URL: ${{ secrets.PRODUCTION_URL }}
    
    - name: Upload performance results
      uses: actions/upload-artifact@v3
      with:
        name: performance-results
        path: performance-results.json
    
    - name: Analyze results and create alert
      run: |
        # Parse results and check thresholds
        node testing/performance/analyze-results.js performance-results.json
    
    - name: Notify if performance degradation
      if: failure()
      uses: 8398a7/action-slack@v3
      with:
        status: failure
        channel: '#alerts'
        message: '⚠️ Performance degradation detected in BDC application!'
      env:
        SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}

  uptime-check:
    name: Uptime Monitoring
    runs-on: ubuntu-latest
    if: github.event_name == 'schedule' || github.event_name == 'workflow_dispatch'
    
    steps:
    - name: Check main application
      run: |
        curl -f "${{ secrets.PRODUCTION_URL }}/health" || exit 1
        echo "Main application is up"
    
    - name: Check API endpoints
      run: |
        curl -f "${{ secrets.PRODUCTION_URL }}/api/health" || exit 1
        curl -f "${{ secrets.PRODUCTION_URL }}/api/auth/status" || exit 1
        echo "API endpoints are responding"
    
    - name: Check database connectivity
      run: |
        curl -f "${{ secrets.PRODUCTION_URL }}/api/health/database" || exit 1
        echo "Database is accessible"
    
    - name: Check Redis connectivity
      run: |
        curl -f "${{ secrets.PRODUCTION_URL }}/api/health/cache" || exit 1
        echo "Redis cache is accessible"
    
    - name: Notify if services are down
      if: failure()
      uses: 8398a7/action-slack@v3
      with:
        status: failure
        channel: '#alerts'
        message: '🚨 BDC services are down! Immediate attention required!'
      env:
        SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}

  ssl-certificate-check:
    name: SSL Certificate Monitoring
    runs-on: ubuntu-latest
    if: github.event_name == 'schedule' || github.event_name == 'workflow_dispatch'
    
    steps:
    - name: Check SSL certificate expiration
      run: |
        # Check certificate expiration (warn if less than 30 days)
        DOMAIN="${{ secrets.PRODUCTION_DOMAIN }}"
        EXPIRY_DATE=$(echo | openssl s_client -servername $DOMAIN -connect $DOMAIN:443 2>/dev/null | openssl x509 -noout -dates | grep notAfter | cut -d= -f2)
        EXPIRY_EPOCH=$(date -d "$EXPIRY_DATE" +%s)
        CURRENT_EPOCH=$(date +%s)
        DAYS_UNTIL_EXPIRY=$(( ($EXPIRY_EPOCH - $CURRENT_EPOCH) / 86400 ))
        
        echo "SSL certificate expires in $DAYS_UNTIL_EXPIRY days"
        
        if [ $DAYS_UNTIL_EXPIRY -lt 30 ]; then
          echo "SSL certificate expires soon!"
          exit 1
        fi
    
    - name: Notify SSL certificate expiration
      if: failure()
      uses: 8398a7/action-slack@v3
      with:
        status: warning
        channel: '#alerts'
        message: '⚠️ SSL certificate for BDC will expire soon! Please renew.'
      env:
        SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}

  backup-verification:
    name: Backup Verification
    runs-on: ubuntu-latest
    if: github.event_name == 'schedule' && github.event.schedule == '0 2 * * *' # Daily at 2 AM
    
    steps:
    - name: Verify database backup exists
      run: |
        # Check if recent backup exists (within last 24 hours)
        aws configure set aws_access_key_id ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws configure set aws_secret_access_key ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws configure set default.region ${{ secrets.AWS_REGION }}
        
        BACKUP_BUCKET="${{ secrets.BACKUP_S3_BUCKET }}"
        YESTERDAY=$(date -d "yesterday" +%Y-%m-%d)
        
        if aws s3 ls "s3://$BACKUP_BUCKET/database/$YESTERDAY/" | grep -q ".sql"; then
          echo "Database backup verified for $YESTERDAY"
        else
          echo "No database backup found for $YESTERDAY"
          exit 1
        fi
    
    - name: Verify file backup exists
      run: |
        BACKUP_BUCKET="${{ secrets.BACKUP_S3_BUCKET }}"
        YESTERDAY=$(date -d "yesterday" +%Y-%m-%d)
        
        if aws s3 ls "s3://$BACKUP_BUCKET/files/$YESTERDAY/" | grep -q ".tar.gz"; then
          echo "File backup verified for $YESTERDAY"
        else
          echo "No file backup found for $YESTERDAY"
          exit 1
        fi
    
    - name: Notify backup verification failure
      if: failure()
      uses: 8398a7/action-slack@v3
      with:
        status: failure
        channel: '#alerts'
        message: '❌ Backup verification failed! Check backup systems immediately.'
      env:
        SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}

  update-monitoring-config:
    name: Update Monitoring Configuration
    runs-on: ubuntu-latest
    if: github.event_name == 'push' && contains(github.event.head_commit.modified, 'monitoring/')
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Set up kubectl
      uses: azure/setup-kubectl@v3
      with:
        version: 'v1.28.0'
    
    - name: Configure kubectl
      run: |
        echo "${{ secrets.KUBECONFIG_PRODUCTION }}" | base64 -d > kubeconfig
        export KUBECONFIG=kubeconfig
    
    - name: Update Prometheus configuration
      run: |
        export KUBECONFIG=kubeconfig
        kubectl create configmap prometheus-config --from-file=monitoring/prometheus/ -n bdc-monitoring --dry-run=client -o yaml | kubectl apply -f -
        kubectl rollout restart deployment/prometheus -n bdc-monitoring
    
    - name: Update AlertManager configuration
      run: |
        export KUBECONFIG=kubeconfig
        kubectl create configmap alertmanager-config --from-file=monitoring/alertmanager/ -n bdc-monitoring --dry-run=client -o yaml | kubectl apply -f -
        kubectl rollout restart deployment/alertmanager -n bdc-monitoring
    
    - name: Update Grafana dashboards
      run: |
        export KUBECONFIG=kubeconfig
        kubectl create configmap grafana-dashboards --from-file=monitoring/grafana/dashboards/ -n bdc-monitoring --dry-run=client -o yaml | kubectl apply -f -